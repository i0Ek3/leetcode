# 021-030

## 021

还是链表操作，合并两个已经排好序的链表。

初步想法是，用第二个链表中的头指针去和第一个链表进行比较，小于放前面，大于等于放后面，正常链表操作。

感觉想法不好，看了别人的解答，很简单也很明确，直接比较值的大小即可。看来我还需要锻炼基本功～

## 022

生成圆括号，即给定数字 n，要求你生成 n 对圆括号，请输出这 n 对圆括号的所有组合。题意大概就是这样。

说实话关于这道题还真没啥想法，我试着想了想，想来想去还是没想法。然后看了看大神们的解法，使用了递归，感觉还是很迷糊，于是又看了 @连城 的解法，恍然大悟！

虽然他的答案也是基于递归的，但他的答案很容易理解。我来分析一下～

```C++
class Solution {
public:
      vector<string> generateParenthesis (int n) {
          if (n == 0) return vector<string>(1, ""); // 如果 n=0，则输出空
          if (n == 1) return vector<string> (1, "()"); // 如果 n=1，则输出一对圆括号
          vector<string> result; // 定义一个 vector，用来存储结果
          for (int i = 0; i < n; ++i) 
              for (auto inner : generateParenthesis (i)) // inner 表示圆括号里边的括号
                  for (auto outer : generateParenthesis (n - 1 - i)) // outer 表示圆括号外边的括号
                      result.push_back ("(" + inner + ")" + outer); // 将结果保存到 result 中
          return result; // 返回最终的表达式
      }
};
```




