# 021-030

## 021

还是链表操作，合并两个已经排好序的链表。

初步想法是，用第二个链表中的头指针去和第一个链表进行比较，小于放前面，大于等于放后面，正常链表操作。

感觉想法不好，看了别人的解答，很简单也很明确，直接比较值的大小即可。看来我还需要锻炼基本功～

## 022

生成圆括号，即给定数字 n，要求你生成 n 对圆括号，请输出这 n 对圆括号的所有组合。题意大概就是这样。

说实话关于这道题还真没啥想法，我试着想了想，想来想去还是没想法。然后看了看大神们的解法，使用了递归，感觉还是很迷糊，于是又看了 @连城 的解法，恍然大悟！

虽然他的答案也是基于递归的，但他的答案很容易理解。我来分析一下～

```C++
class Solution {
public:
      vector<string> generateParenthesis (int n) {
          if (n == 0) return vector<string>(1, ""); // 如果 n=0，则输出空
          if (n == 1) return vector<string> (1, "()"); // 如果 n=1，则输出一对圆括号
          vector<string> result; // 定义一个 vector，用来存储结果
          for (int i = 0; i < n; ++i) 
              for (auto inner : generateParenthesis (i)) // inner 表示圆括号里边的括号
                  for (auto outer : generateParenthesis (n - 1 - i)) // outer 表示圆括号外边的括号
                      result.push_back ("(" + inner + ")" + outer); // 将结果保存到 result 中
          return result; // 返回最终的表达式
      }
};
```

## 023

021 的时候是合并两个链表，现在是 k 个。即给定多个已排好序的链表，将它们按顺序合并成一个链表，题意就是这样。

简单的想法就是先合并两个，然后再将合并好的和另一个新链表进行合并，如此往复，类似于归并排序，所以还是要用到之前的两个链表合并的函数，但注意判断条件。

## 024

还是链表操作啊？给定一个链表，交换每两个相邻的节点并返回头节点，并且不能修改链表中节点的值。

那么如果给定的链表长度是奇数呢？最后一个还需要换吗？我觉着这有点模糊。

那设定两个指针，分别指向第一个节点和第二个节点，交换值，然后每个指针向后移动两个位置。

好吧，这个想法是真的很蠢，似乎也进行了值的交换，也就是违背了题意。另一个是，没有考虑到一个节点不仅和自身后边的节点有关系，还和前面的节点有关系。

所以，这里我们还需要一个节点，来做什么呢？那就是帮助我们处理头节点没有前继节点的问题。显然，dummy 最为合适了。









