# 011-020

## 011

初以为，是找最大值，即两条线段所构成的矩形面积最大。但前面还有些限制条件，显然你不能找两条最长的线段就完事了的，或者只找相邻的两条线段。

所以，想到的一个结果就是先用一个数组保存排序后的值，再用一个数组保存其对应的下标，然后判断所有可能出现的情况。简单理解为长和宽，这里是短板效应，即两条线段是看长度小的那一个，才算作为宽。

但是怎么移动来判断所有的情况呢？如果是两个循环的话，时间复杂度就比较大了，有 O(n^2)，显然应该还有更好的办法。

另外题设里给出的是 vector，但由于对 C++ 的一些语法特性还不是特别了解，所以想起来很是费劲，也没有考虑到用双指针前后同时扫描。

参考了 pezy 的解答，是真的很简洁。当然，haoel 的 soulmachine 的答案也很漂亮，方法都是双指针前后同时扫描。想必这回应该清晰多了～


## 012

将一个数字转换为罗马数字，范围在 1-3999 之间。正常情况都是一个或两个及两个以上的罗马数字相加来表示一个整数：

    I             1
    V             5
    X             10
    L             50
    C             100
    D             500
    M             1000

即从左到右，从大到小。但有三种情况是用罗马数字相减来表示的：

    I => IV = 4
      => IX = 9
    X => XL = 40
      => XC = 90
    C => CD = 400
      => CM = 900

即从左到右，从小到大。这就是该题中心思想的全部了，现给定一个数字，用罗马数字表示。

初步想法是将罗马数字以键值对或者数组保存，并判断减法的三种情况，然后可通过暴力枚举来计算给定数字的表示。

但这个想法还不够优秀，参考了 pezy 和 soulmachine 的解答后，发现只要缓存好上面我们表示出来的数字不就好了吗？根本不需要暴力破解。

于是就简单多了，而 pezy 的代码更符合 C++ 和我的口味。

## 013

Easy 级别，和上一道题相反，从后开始往前遍历。关键点如下：

```C++
    if (m[s[i]] < m[s[i + 1]]) { // 比较最后两个，依次往前
        ret -= m[s[i]]; // 小则说明运算减法，如 IV
    } else { // >= 则为加法，如 II
        ret += m[s[i]];
    }
```

## 014

最长共同前缀。给定三个字符串，字符串由 a-z 构成，找出他们的最长共同前缀，Easy 级别。

初步想法是，先判断最短的那个字符串是否能和其他两个中的一个字符串重合，重合则比较最短字符串和另一个字符串，否则单个字符比较当前字符串。

看了别人的解答才发现我想的复杂了，似乎我对 vector 的用法还是不熟练，好多特性都不知道。目前的级别也只能这样了，希望日后可以有所改善，然后再来添加更优的解决方案。


## 015

3Sum，即在给定数组中求 a + b + c = 0，输出集合，集合中包括这三个数组成的数组的所有可能，但没有重复。

那暴力破解肯定是不可取的，因为我讨厌太高的复杂度。但说实在的，我目前还真没想到更好的办法。原本想过使用双指针，但是我对指针的操作太菜，只停留在表面阶段，那让我们来看看大神们的优秀解答吧！

直接来到评论区，大神云集啊～ 大家所采取的策略就是双指针，先排序，然后首尾指针双面夹击。


## 016

类似上一题，不过这题是要找出与目标和最为接近的答案。这就要我们分析所有的结果，然后比较哪个最为接近 target。或许也需要对三个数的和排个序？不知道，但是与 target 最接近的值的 target + 1 和 target - 1.

看了[这里](https://stackoverflow.com/questions/2070359/finding-three-elements-in-an-array-whose-sum-is-closest-to-a-given-number)的回答，感觉容易很多，似乎将问题做了些小的转化，让问题变得更加简单，让时间复杂度维持在 O(n^2)。

即还是先对目标数组进行排序，然后用三个索引迭代整个数组。其中一个指向数组的开始，另两个分别指向数组第二个元素和最后一个元素。最终的情况无外乎相等、大于和小于。等于则返回 target，大于或者小于用绝对值解决。


## 017

手机拨号界面的数字键盘里的数字都对应着一些字母，数字 1 除外。问给定数字的组合，求出对应的字母组合。如下面所示：

    Input: "23"
    Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].

首先可以将数字所对应的字母用 vector 保存起来，然后看给定的数字是哪个，再进行字母组合，初步想法就是这样。

参考了 pezy 的解答，发现真的很简洁，我的想法和他的还有些出入，向大神学习。另外，记得判断输入空字符串的情况。


## 018

4Sum，之前 3Sum 采用的是双指针思想，那这个呢？当然也可以了！实际上的解答和 3Sum 还是很类似的，就是通过分解现有问题，降级到 3Sum 来求解。即 NSum 问题可以化解为（N-1)Sum 问题。

参考了评论区的代码，这个例子非常简单。就是先计算 3 个数字的情况，再计算 2 个数字的情况，不断分解，类似于算法中的分治思想。


## 019

链表操作，按给定数字倒序移除链表中的结点。比如 n = 3，则在链表上从后往前数3，则移除该处的结点。

初步想法是，可以先反转链表，然后直接删除指定位置的结点，但在链表较长的情况下就不好玩了。或者不反转，再使用一个尾指针来解决。

对于链表中的结点的删除，有两种方法。一种就是直接删除，书中所讲的那样，复杂度较高。还有一种就是利用二级指针，直接替换指定位置的结点，简单粗暴。

这也就是人们常说的快慢指针问题了，即有两个指针，一个先跑 n 步，然后两个再一起跑。这样，前一个迭代完所有元素之时，后一个指针的 next 所指的便是我们要删除的位置了。

总的来说，该题的难度不是很大。








