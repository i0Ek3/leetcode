# 011-020

## 011

初以为，是找最大值，即两条线段所构成的矩形面积最大。但前面还有些限制条件，显然你不能找两条最长的线段就完事了的，或者只找相邻的两条线段。

所以，想到的一个结果就是先用一个数组保存排序后的值，再用一个数组保存其对应的下标，然后判断所有可能出现的情况。简单理解为长和宽，这里是短板效应，即两条线段是看长度小的那一个，才算作为宽。

但是怎么移动来判断所有的情况呢？如果是两个循环的话，时间复杂度就比较大了，有 O(n^2)，显然应该还有更好的办法。

另外题设里给出的是 vector，但由于对 C++ 的一些语法特性还不是特别了解，所以想起来很是费劲，也没有考虑到用双指针前后同时扫描。

参考了 pezy 的解答，是真的很简洁。当然，haoel 的 soulmachine 的答案也很漂亮，方法都是双指针前后同时扫描。想必这回应该清晰多了～


## 012

将一个数字转换为罗马数字，范围在 1-3999 之间。正常情况都是一个或两个及两个以上的罗马数字相加来表示一个整数：

    I             1
    V             5
    X             10
    L             50
    C             100
    D             500
    M             1000

即从左到右，从大到小。但有三种情况是用罗马数字相减来表示的：

    I => IV = 4
      => IX = 9
    X => XL = 40
      => XC = 90
    C => CD = 400
      => CM = 900

即从左到右，从小到大。这就是该题中心思想的全部了，现给定一个数字，用罗马数字表示。

初步想法是将罗马数字以键值对或者数组保存，并判断减法的三种情况，然后可通过暴力枚举来计算给定数字的表示。

但这个想法还不够优秀，参考了 pezy 和 soulmachine 的解答后，发现只要缓存好上面我们表示出来的数字不就好了吗？根本不需要暴力破解。

于是就简单多了，而 pezy 的代码更符合 C++ 和我的口味。



